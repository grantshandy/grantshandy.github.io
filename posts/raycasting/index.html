<!doctype html><html lang=en><head><title>Write a First Person Game in 2KB With Rust ::
grantsh</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction # On first glance, making a first person game without an engine or a graphics API seems like an almost impossible task. In this post I&amp;rsquo;ll show you how to do that using an algorithm called ray casting.
My goal here is to show how something that looks complicated can be broken down into simple pieces, and if I&amp;rsquo;ve done my job right, it should feel like you&amp;rsquo;ve discovered how the game works."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://grantshandy.github.io/posts/raycasting/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://grantshandy.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://grantshandy.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://grantshandy.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://grantshandy.github.io/posts/raycasting/cover.png"><meta name=twitter:title content="Write a First Person Game in 2KB With Rust"><meta name=twitter:description content="Learn about ray casting and discover some elegant math by creating a tiny 2KB game with Rust."><meta property="og:title" content="Write a First Person Game in 2KB With Rust"><meta property="og:description" content="Learn about ray casting and discover some elegant math by creating a tiny 2KB game with Rust."><meta property="og:type" content="article"><meta property="og:url" content="https://grantshandy.github.io/posts/raycasting/"><meta property="og:image" content="https://grantshandy.github.io/posts/raycasting/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-24T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-24T00:00:00+00:00"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,align:"center",theme:"neutral"})</script><script src=https://www.geogebra.org/apps/deployggb.js></script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=https://grantshandy.github.io/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>grantsh</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/showcase>Showcase</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/showcase>Showcase</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>Write a First Person Game in 2KB With Rust</h1><div class=post-meta><time class=post-date>2023-02-24</time>
<span class=post-read-time>â€” 30 min read</span></div><figure class=post-cover><img src=https://grantshandy.github.io/posts/raycasting/cover.png alt="Write a First Person Game in 2KB With Rust"></figure><div class=post-content><h2>Table of Contents</h2><aside class=table-of-contents><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#wolfenstein-3d>Wolfenstein 3D</a></li></ul></li><li><a href=#the-algorithm>The Algorithm</a><ul><li><a href=#the-basics>The Basics</a></li><li><a href=#digging-deeper>Digging Deeper</a></li><li><a href=#horizontal-intersections>Horizontal Intersections</a></li><li><a href=#vertical-intersections>Vertical Intersections</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#implementation>Implementation</a><ul><li><a href=#project-setup>Project Setup</a></li><li><a href=#storing-the-map>Storing The Map</a></li><li><a href=#maintaining-game-state>Maintaining Game State</a></li><li><a href=#moving-the-character>Moving the Character</a></li><li><a href=#horizontal-intersections-1>Horizontal Intersections</a></li><li><a href=#vertical-intersections-1>Vertical Intersections</a></li><li><a href=#getting-the-view>Getting The View</a></li></ul></li><li><a href=#fixing-the-perspective>Fixing The Perspective</a></li><li><a href=#adding-some-depth>Adding Some Depth</a></li><li><a href=#making-it-smaller>Making It Smaller!</a></li><li><a href=#somehow-even-smaller>Somehow Even Smaller?!</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><h2 id=introduction>Introduction
<a href=#introduction class=h-anchor aria-hidden=true>#</a></h2><p>On first glance, making a first person game without an engine or a graphics API seems like an almost impossible task.
In this post I&rsquo;ll show you how to do that using an algorithm called ray casting.</p><p>My goal here is to show how something that looks complicated can be broken down into simple pieces,
and if I&rsquo;ve done my job right, it should feel like you&rsquo;ve <em>discovered</em> how the game works.</p><p>First, we&rsquo;ll explore how the algorithm behind the game works, then we&rsquo;ll write it out line by line.
Afterwards, we&rsquo;ll take a second look at the code to add some features and optimize it for size.
I&rsquo;ve tried to make this as accessible and friendly as possible but a healthy understanding of programming as well as Rust and basic geometry will help.</p><p>Here&rsquo;s a quick preview of what we&rsquo;ll be making:</p><figure class=center><video style=border-radius:8px;transform:translateX(-25%);-webkit-transform:translateX(-25%);margin-left:auto;margin-right:auto width=200% height=200% autoplay loop muted>
<source src=preview.webm type=video/webm></video></figure><p>My first experience with games like this (though I didn&rsquo;t know at the time), was in middle school with games like <a href=https://www.ticalc.org/archives/files/fileinfo/360/36062.html rel=noopener target=_blank>zDoom</a> on my calculator.
zDoom (while not actually that fun), was fascinating to me because it could (kind of) create the illusion of depth and perspective, something I thought only &ldquo;real&rdquo; games could do.</p><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/zdoom_hucd3a988ec9303721f97c0417fb7ec03b_652_250x0_resize_box_3.png width=250 height=167></figure><p>zDoom was only an imitation of the original game Doom, in reality, it was much closer to Doom&rsquo;s predecessor, Wolfenstein 3D.</p><h3 id=wolfenstein-3d>Wolfenstein 3D
<a href=#wolfenstein-3d class=h-anchor aria-hidden=true>#</a></h3><p>Famously, <a href=https://en.wikipedia.org/wiki/Wolfenstein_3D rel=noopener target=_blank>Wolfenstein 3D</a>, released in 1992, was one of the first 3D first-person games to run on consumer PCs.
Back then, computers didn&rsquo;t have hardware 3D acceleration, let alone dedicated graphics cards, so how was this done?</p><figure class=center><img src=https://upload.wikimedia.org/wikipedia/en/6/69/Wolf3d_pc.png><figcaption class=center>A screenshot from wolfenstein 3D</figcaption></figure><p>Well, I should have said <a href=https://en.wikipedia.org/wiki/2.5D rel=noopener target=_blank><em>pseudo</em>-3D</a> because no part of the game ran in three dimensions.
The core of the game was an algorithm called ray casting<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, a process of projecting a 2D game into a 3D perspective.</p><p>All the game entities were located at simple x and y positions on the map and could not move vertically.
Upon release, I&rsquo;m sure that this didn&rsquo;t matter, but with our current standards, it shows its age.
The player could not look up or down, let alone crouch or jump.</p><figure class=center><img src=wolfenstein-map.png><figcaption class=center>A top-down view of the first level of Wolfenstein 3D</figcaption></figure><p>To add to that, all the levels were composed of single floors of buildings with no windows.
Also, all walls were perfectly straight with corners placed at even intervals (something that will absolutely not come up later).
These design features were all put here because of some of the essential restrictions of its simple ray-casting algorithm.</p><h2 id=the-algorithm>The Algorithm
<a href=#the-algorithm class=h-anchor aria-hidden=true>#</a></h2><h3 id=the-basics>The Basics
<a href=#the-basics class=h-anchor aria-hidden=true>#</a></h3><p>At the most fundamental level, ray casting depends on the simple fact that objects that are further away from us appear smaller while objects that are closer appear larger.
Ray casting uses this fact to draw walls at shorter heights the further away they are from the player and at taller heights the closer they are.</p><p>Just this simple idea alone creates a convincing illusion of depth and allows us to move our player around just as if it were being rendered in actual 3D.</p><p>Ray casting <em>works</em> by tracing a path from the player to the closest wall for each column in the player&rsquo;s view.
It then records the distances of each path before converting it into the height of a wall and drawing it on the screen as a vertical line.</p><figure class=center><img src=figure-overview.svg></figure><p>From what we know so far about the ray casting algorithm we can deduce that we will need to:</p><ul><li>Cast a ray from the player and stop at the nearest wall</li><li>Calculate the distance from the player to the nearest wall</li><li>Convert that distance into the height of a wall and draw it on the screen</li><li>Repeat that for each column on the screen â†º</li></ul><h3 id=digging-deeper>Digging Deeper
<a href=#digging-deeper class=h-anchor aria-hidden=true>#</a></h3><p>The hardest part of this is &ldquo;cast a ray from the player and stop at the nearest wall&rdquo;.
This seems simple on paper but in practice, it can be <a href=https://en.wikipedia.org/wiki/Collision_detection rel=noopener target=_blank>pretty difficult</a>.
If you had to come up with a ray casting implementation yourself, how would you approach it?</p><figure class=center><img src=figure-question.svg><figcaption class=center>The Intersection Problem</figcaption></figure><p>The first idea most people would probably have is to repeatedly extend the ray<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> a small amount and stop when it hits a wall.
This is problematic because we might skip over the wall entirely when extending the ray.
And if the ray does hit the wall correctly it will have very low accuracy because it won&rsquo;t know exactly where the wall started, just that it landed in one.</p><figure class=center><img src=figure-naive.svg><figcaption class=center>The Naive Solution</figcaption></figure><p>What we need is to find a way that we can <em>guarantee</em> that the ray will intersect with a wall and that it will stop right on the border of that wall.
In math land, we might be able to do this by extending the ray an infinitely small distance infinitely many times.
Sadly, we&rsquo;re not in math land so we can&rsquo;t do that.</p><p>The solution to this, as you might have guessed from the earlier foreshadowing, is to align all the walls to a grid.
If we know that the walls fall at predictable intervals we can calculate a reliable distance to extend our ray each time.</p><figure class=center><img src=figure-solution.svg><figcaption class=center>Notice a pattern?</figcaption></figure><p>But how will the ray jump to the wall?</p><p>If you get out some grid paper and sketch out the lines between the player to various walls you&rsquo;ll start to notice some patterns.
Ray &ldquo;extensions&rdquo; on their way to walls on horizontal grid lines all share a common width while ray &ldquo;extensions&rdquo; that land on walls at vertical grid lines all share a common height.</p><p>Once we extend the ray to the first grid line we can calculate these shared &ldquo;extension widths&rdquo; and &ldquo;extension heights&rdquo;.
Then we repeatedly extend it by these widths and heights to get the closest &ldquo;vertical wall&rdquo; and &ldquo;horizontal wall&rdquo; then use the smaller of the two distances.</p><p>I admit this is a bit confusing so I&rsquo;ll explain what this means in more depth:</p><h3 id=horizontal-intersections>Horizontal Intersections
<a href=#horizontal-intersections class=h-anchor aria-hidden=true>#</a></h3><p>Here&rsquo;s an example diagram of what it looks like when a player looks at a &ldquo;horizontal wall&rdquo;.
This diagram is interactive, try dragging around the player!</p><script>window.addEventListener("load",function(){new GGBApplet({appName:"geometry",id:"horizontal",width:800,height:600,showToolBar:!1,showZoomButtons:!1,showAlgebraInput:!1,showLogging:!1,enableRightClick:!1,enableShiftDragZoom:!1,preventFocus:!0,showMenuBar:!1,appletOnLoad:e=>{e.setCoordSystem(-2.78,13.18,-4.48,7.48)},filename:"https://grantshandy.github.io/ggb/horizontal.ggb"}).inject("horizontal")})</script><figure class=center><div id=horizontal style=border-radius:8px;overflow:hidden></div><figcaption class=center>Notice how only the <em>width</em> between extensions changes when the player moves.</figcaption></figure><p>In horizontal wall intersections the height between &ldquo;extensions&rdquo; is always one, while the width between extensions can be derived from the angle of the ray.
We always move up or down by exactly one and right or left by an amount determined by the angle of the ray.</p><p>You can see this by looking at the diagram, the width between $A_x$ and $B_x$ is the same as the width between $B_x$ and $C_x$, and the difference in height between all the points is just one.</p><p>Using some simple trigonometry we can find the width between horizontal grid intersections from the angle of the player.
I&rsquo;m going to save you the work and just give you the definition:</p><p>$$ \Delta H = \begin{cases} 1 &\text{if &ldquo;facing up&rdquo;} \\ -1 &\text{if &ldquo;facing down&rdquo;} \end{cases} $$
$$ \Delta W = \frac{\Delta H}{\tan(\theta)} $$</p><h3 id=vertical-intersections>Vertical Intersections
<a href=#vertical-intersections class=h-anchor aria-hidden=true>#</a></h3><p>Here&rsquo;s another interactive diagram of what it looks like when a ray intersects with a &ldquo;vertical wall&rdquo;.</p><script>window.addEventListener("load",function(){new GGBApplet({appName:"geometry",id:"vertical",width:800,height:600,showToolBar:!1,showZoomButtons:!1,showAlgebraInput:!1,showLogging:!1,enableRightClick:!1,enableShiftDragZoom:!1,preventFocus:!0,showMenuBar:!1,appletOnLoad:e=>{e.setCoordSystem(-3.097,8.238,2.274,10.769)},filename:"https://grantshandy.github.io/ggb/vertical.ggb"}).inject("vertical")})</script><figure class=center><div id=vertical style=border-radius:8px;overflow:hidden></div><figcaption class=center>Here the <em>height</em> between extensions changes while the width stays the same.</figcaption></figure><p>Vertical grid intersections are the same as horizontal grid intersections, just rotated 90Â°.
In vertical grid intersections the <em>width</em> between our &ldquo;ray extensions&rdquo; is constant while the <em>height</em> is created from the angle of the ray.
Like last time, I&rsquo;m going to skip ahead and define our variables for you.</p><p>$$ \Delta W = \begin{cases} 1 &\text{if &ldquo;facing right&rdquo;} \\ -1 &\text{if &ldquo;facing left&rdquo;} \end{cases} $$
$$ \Delta H = \Delta W * \tan(\theta) $$</p><h3 id=summary>Summary
<a href=#summary class=h-anchor aria-hidden=true>#</a></h3><p>Now that we know pretty much exactly how we&rsquo;ll do this we can compile it into a more detailed step-by-step list for our program to execute on each frame.</p><p>For each column on the screen:</p><ol><li>Find the angle for the ray from the player&rsquo;s angle and field of view.</li><li>Determine the distance to the nearest wall that the ray intersects with:<ul><li>Get the first &ldquo;horizontal&rdquo; wall the ray intersects with.</li><li>Get the first &ldquo;vertical&rdquo; wall the ray intersects with.</li><li>Calculate the distance to the wall from the closest of those two.</li></ul></li><li>Convert that distance into the height of a wall on the screen and then draw it.</li></ol><h2 id=implementation>Implementation
<a href=#implementation class=h-anchor aria-hidden=true>#</a></h2><p>Now that we understand how the underlying algorithm works we can write a program that implements it using WASM-4.</p><p>Wait why WASM-4?
The official answer is that we need a way for our program to accept user input and draw to the screen.
The real answer is because I like it a lot.</p><p><a href=https://wasm4.org rel=noopener target=_blank>WASM-4</a> is a tiny game engine that runs WebAssembly (<code>.wasm</code>) files.
Most compiled programming languages (C, C++, Rust, Zig, etc.) can compile to WebAssembly which means games for WASM-4 can be written in any of those languages!
WASM-4 is <em>extremely</em> minimal, the &ldquo;4&rdquo; in &ldquo;WASM-4&rdquo; is there because you can only draw four colors on screen at once.</p><p>I&rsquo;ll be using Rust, but you could follow along with any language that can compile to WebAssembly.
If you&rsquo;re more familiar with JavaScript I recommend <a href=https://assemblyscript.org rel=noopener target=_blank>AssemblyScript</a>.</p><div class=mermaid style=text-align:center>graph LR
source[lib.rs] --> compiler[rustc] --> wasm
subgraph wasm4[WASM-4]
wasm[game.wasm]
end
wasm4--> player[Player]</div><p>WASM-4 will let us create <em>tiny</em> games because it provides a simple platform to build off.
WASM-4 handles windowing, graphics rendering, and gamepad input, we have to do everything else.</p><p>Here are the specs for the WASM-4 &ldquo;fantasy console&rdquo; from the website:</p><blockquote><ul><li>Display: 160x160 pixels, 4 customizable colors, updated at 60 Hz.</li><li>Memory: 64 KB linear RAM, memory-mapped I/O, save states.</li><li>Cartridge Size Limit: 64 KB.</li><li>Input: Keyboard, mouse, touchscreen, up to 4 gamepads.</li><li>Audio: 2 pulse wave channels, 1 triangle wave channel, 1 noise channel.</li><li>Disk Storage: 1024 bytes.</li></ul></blockquote><p>If you know a bit about computer hardware you&rsquo;ll know this is an <em>incredibly</em> restrictive environment for a game to run in.
That&rsquo;s the fun of it though, seeing how much you can cram into 160x160px, 4 colors, and 64KB of disk space.
If you want to see what people are able to create with it, check out the <a href=https://wasm4.org/play rel=noopener target=_blank>WASM-4 site</a> for some very impressive games (including a flight simulator!).</p><p>I&rsquo;ll probably make a more in-depth post on WASM-4 in the future, but for now, this explanation should be good enough for our case.
All you need to run WASM-4 games is to <a href=https://wasm4.org/docs/getting-started/setup>download and install the minimal runtime</a>.</p><h3 id=project-setup>Project Setup
<a href=#project-setup class=h-anchor aria-hidden=true>#</a></h3><p>Because WASM-4 runs WebAssembly files we have to configure our project to create one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo new raycaster --lib <span style=color:#f92672>&amp;&amp;</span> cd raycaster
</span></span></code></pre></div><p>Add this to to <code>Cargo.toml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>lib</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>crate-type</span> = [<span style=color:#e6db74>&#34;cdylib&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>profile</span>.<span style=color:#a6e22e>release</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>opt-level</span> = <span style=color:#e6db74>&#34;z&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lto</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>codegen-units</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>strip</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>panic</span> = <span style=color:#e6db74>&#34;abort&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>libm</span> = <span style=color:#e6db74>&#34;0.2&#34;</span>
</span></span></code></pre></div><p>This will tell cargo that we want to produce a C-like dynamic library (<code>.wasm</code>), and optimize the binary for size.
We also import <a href=https://crates.io/crates/libm rel=noopener target=_blank><code>libm</code></a>, a library that will provide us with some <code>no_std</code> implementations of functions we need like <code>sin</code>, <code>tan</code>, and <code>floor</code>. (more on that later)</p><p>In our crate configuration file <code>.cargo/config.toml</code> let&rsquo;s add:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>build</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>target</span> = <span style=color:#e6db74>&#34;wasm32-unknown-unknown&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>wasm32-unknown-unknown</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>rustflags</span> = [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=--import-memory&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=--initial-memory=65536&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=--max-memory=65536&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=-zstack-size=14752&#34;</span>,
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>This will tell cargo to use WebAssembly by default and to pass some flags to rustc which tells our program to reserve some memory for the game.</p><p>Now, let&rsquo;s add some simple boilerplate to our source file <code>src/lib.rs</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#![no_std]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> core::{arch::wasm32, panic::PanicInfo};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> GAMEPAD1: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x16</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> BUTTON_LEFT: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;  <span style=color:#75715e>// 00010000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> BUTTON_RIGHT: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>; <span style=color:#75715e>// 00100000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> BUTTON_UP: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;    <span style=color:#75715e>// 01000000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> BUTTON_DOWN: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>128</span>; <span style=color:#75715e>// 10000000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>vline</span>(x: <span style=color:#66d9ef>i32</span>, y: <span style=color:#66d9ef>i32</span>, len: <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[panic_handler]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>phandler</span>(_: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PanicInfo</span><span style=color:#f92672>&lt;&#39;</span>_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#f92672>!</span> {
</span></span><span style=display:flex><span>    wasm32::unreachable();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>update</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_UP <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        vline(<span style=color:#ae81ff>80</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>120</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here&rsquo;s a little explanation of the code here for those who aren&rsquo;t familiar with Rust or WASM-4:</p><ul><li><p><code>#![no_std]</code> prohibits the program from accessing the Rust standard library.
This is essential in almost all WASM-4 games because the standard library is large and might put our game over the 64KB size limit.</p></li><li><p><a href=https://wasm4.org/docs/reference/memory#gamepads rel=noopener target=_blank><code>GAMEPAD1</code></a> is a pointer to the current state of the first gamepad (the arrow keys in our case).
The runtime will update this section of memory with the state of our gamepad (keyboard) on each frame.</p></li><li><p>The constants <code>BUTTON_LEFT</code> through <code>BUTTON_DOWN</code> describe the bits in the gamepad which describe each button.
We can use these to check if <code>GAMEPAD1</code> says that a button is down, that&rsquo;s what we&rsquo;re doing when we call <code>*GAMEPAD1 & BUTTON_UP != 0</code>.</p></li><li><p><code>extern "C" fn vline</code> links our game to an external function WASM-4 provides for us, <a href=https://wasm4.org/docs/reference/functions/#vlinex-y-len rel=noopener target=_blank><code>vline</code></a>.
<code>vline</code> draws a vertical line on the window at <code>x</code>, <code>y</code> and extends it down <code>len</code> pixels.</p></li><li><p><code>#[panic_handler] fn phandler</code> is a little bit of boilerplate that Rust requires we provide if we choose to use <code>#![no_std]</code>. This function will run when the program panics. Because WASM-4 is such a restrictive environment the only thing we can really do is call <code>wasm32::unreachable()</code>.</p></li><li><p><a href=https://wasm4.org/docs/reference/functions/#update- rel=noopener target=_blank><code>unsafe fn update</code></a> is the main entry point into our program, WASM-4 calls this function on each frame.</p></li></ul><p>To compile our game we can build it just like any other crate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span> $ cargo build --release
</span></span></code></pre></div><p>And to run it we can use <code>w4 run-native</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span> $ w4 run-native target/wasm32-unknown-unknown/release/raycaster.wasm
</span></span></code></pre></div><p>This will launch an empty window, and if we press the up arrow on the keyboard a vertical line will appear in all its green Gameboy-ish style.</p><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/screenshot-one_hu6645eafa6345d1ac0df32fe26e4baf4a_704_300x0_resize_box_3.png width=300 height=300></figure><p>It&rsquo;s alive!</p><p>One thing I like to do in a situation with commands like this that weâ€™re going to call often is to put these commands in a simple Makefile so we donâ€™t have to re-type the commands or overuse the up arrow.
After that all we have to do to build and run the program is type <code>make run</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>all</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    cargo build --release
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>run</span><span style=color:#f92672>:</span> all
</span></span><span style=display:flex><span>    w4 run-native target/wasm32-unknown-unknown/release/raycaster.wasm
</span></span></code></pre></div><p>Great, now that we&rsquo;ve got the workflow down we can get to writing the game.</p><h3 id=storing-the-map>Storing The Map
<a href=#storing-the-map class=h-anchor aria-hidden=true>#</a></h3><p>The simplest way to store the map is a grid of wall or no wall. One way we could store the map as <code>[[bool; WIDTH]; HEIGHT]</code> and access it through <code>map[][]</code>.
Storing the map this way wouldn&rsquo;t be very elegant because we&rsquo;d have to type out each cell individually as a <code>true</code> or <code>false</code>.</p><p>Because the boolean value (wall or no wall) can be represented by a single bit we can use the bits inside of a number to represent the map: <code>[u16; HEIGHT]</code>.
In this case, <code>[u16; HEIGHT]</code> can represent a map with a width of 16 cells and an arbitrary height of our choosing.
Using Rust&rsquo;s integer literal syntax we can represent our map pretty simply by writing a <code>1</code> where there is a wall and a <code>0</code> where there is no wall:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> MAP: [<span style=color:#66d9ef>u16</span>; <span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1111111111111111</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1000001010000101</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1011100000110101</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1000111010010001</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1010001011110111</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1011101001100001</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1000100000001101</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0b1111111111111111</span>,
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>The more difficult thing about this way of storing the map is accessing it.
To do this we have to write a function that first indexes into the row then into the specific column by masking and then shifting the row.
This post is already long as it is so for the sake of time I&rsquo;m not going to go in-depth about how the X coordinate lookup bit operations works in this function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Check if the map contains a wall at a point.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>point_in_wall</span>(x: <span style=color:#66d9ef>f32</span>, y: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> MAP.get(y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>        Some(line) <span style=color:#f92672>=&gt;</span> (line <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>0b1</span> <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because our map is surrounded by walls it&rsquo;s safe to tell the caller of this function that there is a wall if it calls for a coordinate that is out of bounds.</p><blockquote><p>One thing to note about <code>point_in_wall</code> is that the Y axis is &ldquo;flipped&rdquo; meaning $ y = 0 $ is at the top.
This is not only faster but reflects the <a href=http://www.e-cartouche.ch/content_reg/cartouche/graphics/en/html/Screen_learningObject3.html rel=noopener target=_blank>coordinate system software most commonly uses</a>.</p></blockquote><h3 id=maintaining-game-state>Maintaining Game State
<a href=#maintaining-game-state class=h-anchor aria-hidden=true>#</a></h3><p>The map stays constant throughout the runtime of the program, but the player&rsquo;s position and angle change.
Because WASM-4 calls <code>update</code> on each frame the only way to store our game state across frames is via something like Rust&rsquo;s <a href=https://doc.rust-lang.org/reference/items/static-items.html rel=noopener target=_blank><code>static mut</code></a>.
Because <code>static mut</code> is <a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html rel=noopener target=_blank><code>unsafe</code></a> we should consolidate our game logic and state in a single <code>struct</code> so we minimize the number of times we modify our state through <code>static mut</code>.</p><p>Only three variables are required to describe the player&rsquo;s view: the X and Y position and viewing angle.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    player_x: <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>    player_y: <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>    player_angle: <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>}    
</span></span></code></pre></div><p>Now let&rsquo;s put the <code>State</code> in a <code>static mut</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>mut</span> STATE: <span style=color:#a6e22e>State</span> <span style=color:#f92672>=</span> State {
</span></span><span style=display:flex><span>    player_x: <span style=color:#ae81ff>1.5</span>,
</span></span><span style=display:flex><span>    player_y: <span style=color:#ae81ff>1.5</span>,
</span></span><span style=display:flex><span>    player_angle: <span style=color:#ae81ff>0.0</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><blockquote><p><em><code>player_x</code> and <code>player_y</code> are both initially set at 1.5 so the player starts in the center of a cell and not inside a wall.</em></p></blockquote><p>Not only is accessing <code>State</code> <code>unsafe</code> behavior, but most interactions with WASM-4 are also. (dereferencing raw pointers, calling external functions, etc.)</p><p>For those not familiar with Rust, <code>unsafe</code> is a keyword/block that you give the compiler when you need to get around its memory safety guarantees.
Using <code>unsafe</code> tells the Rust compiler &ldquo;I know what I&rsquo;m doing, don&rsquo;t bother me about it&rdquo;.
The problem is that often we don&rsquo;t know what we&rsquo;re doing.
Because of this, best practice is to keep <code>unsafe</code> usage to a minimum.</p><p>If we consolidate <code>unsafe</code> behavior into <code>fn update</code> and game logic into <code>State</code> we isolate our state and give some structure to our program.
This gives us a pretty clear line: <code>unsafe</code> I/O with WASM-4 in <code>fn update</code>, safe game logic in <code>State</code>.</p><div class=mermaid style=text-align:center>flowchart
subgraph unsafe
w[WASM-4] --> f[fn update]
end
f --> u[struct State]</div><h3 id=moving-the-character>Moving the Character
<a href=#moving-the-character class=h-anchor aria-hidden=true>#</a></h3><p>One of the easier parts of this game is moving the character.
Because accessing our <code>STATE</code> from outside is <code>unsafe</code>, let&rsquo;s create a method inside of <code>State</code> to move the character and pass in the inputs on each frame.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// move the character
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>update</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, up: <span style=color:#66d9ef>bool</span>, down: <span style=color:#66d9ef>bool</span>, left: <span style=color:#66d9ef>bool</span>, right: <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// store our current position in case we might need it later
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> previous_position <span style=color:#f92672>=</span> (self.player_x, self.player_y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> up {
</span></span><span style=display:flex><span>            self.player_x <span style=color:#f92672>+=</span> cosf(self.player_angle) <span style=color:#f92672>*</span> STEP_SIZE;
</span></span><span style=display:flex><span>            self.player_y <span style=color:#f92672>+=</span> <span style=color:#f92672>-</span>sinf(self.player_angle) <span style=color:#f92672>*</span> STEP_SIZE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> down {
</span></span><span style=display:flex><span>            self.player_x <span style=color:#f92672>-=</span> cosf(self.player_angle) <span style=color:#f92672>*</span> STEP_SIZE;
</span></span><span style=display:flex><span>            self.player_y <span style=color:#f92672>-=</span> <span style=color:#f92672>-</span>sinf(self.player_angle) <span style=color:#f92672>*</span> STEP_SIZE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> right {
</span></span><span style=display:flex><span>            self.player_angle <span style=color:#f92672>-=</span> STEP_SIZE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left {
</span></span><span style=display:flex><span>            self.player_angle <span style=color:#f92672>+=</span> STEP_SIZE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if moving us on this frame put us into a wall just revert it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> point_in_wall(self.player_x, self.player_y) {
</span></span><span style=display:flex><span>            (self.player_x, self.player_y) <span style=color:#f92672>=</span> previous_position;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you&rsquo;ve ever moved a player in a game and know some basic trigonometry this should all look familiar.
Note that calls to <code>sinf</code> are negative because our Y-axis is flipped.</p><p>If the player is asking us to move the player forwards or backward we modify the player&rsquo;s x and y positions based on the <code>cosf</code> and <code>sinf</code> values of the player&rsquo;s angle multiplied by a constant <code>STEP_SIZE</code>.</p><p>Just for you, I&rsquo;ll give you a magic number that works pretty well.
You can change later it if you&rsquo;d like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> STEP_SIZE: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.045</span>;
</span></span></code></pre></div><p>The last thing that we need to make this function work is to import <code>cosf</code> and <code>sinf</code> from <code>libm</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> libm::{cosf, sinf};
</span></span></code></pre></div><blockquote><p><em>Why <code>sinf/cosf</code> and not <code>sin/cos</code>? This naming convention comes from C&rsquo;s libm where <code>sin/cos</code> handles doubles and <code>sinf/cosf</code> handles floats.</em>
<em>In Rust&rsquo;s implementation of <code>libm</code> this means <code>fn cos(x: f64) -> f64</code> and <code>fn cosf(x: f32) -> f32</code>.</em>
<em>We&rsquo;re using <code>f32</code> and not <code>f64</code> here because it saves space and we don&rsquo;t need the precision.</em></p></blockquote><p>The last thing we need to do&mldr; is call our new <code>State::update</code> of course!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>update</span>() {
</span></span><span style=display:flex><span>    STATE.update(
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_UP <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_DOWN <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_LEFT <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_RIGHT <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=horizontal-intersections-1>Horizontal Intersections
<a href=#horizontal-intersections-1 class=h-anchor aria-hidden=true>#</a></h3><p>Before we draw the walls on the screen we need to implement the core of our algorithm: horizontal and vertical intersection checks.</p><p>First, we need to expand our <code>libm</code> import statement from earlier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> libm::{ceilf, cosf, fabsf, floorf, sinf, sqrtf, tanf};
</span></span></code></pre></div><p>Using <code>libm::sqrtf</code> we can make a distance function $ D = \sqrt{(\Delta X^2)+(\Delta Y^2)} $:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>distance</span>(a: <span style=color:#66d9ef>f32</span>, b: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    sqrtf((a <span style=color:#f92672>*</span> a) <span style=color:#f92672>+</span> (b <span style=color:#f92672>*</span> b))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, lets import the core library&rsquo;s helpful constants for $\pi$ and $\frac{\pi}{2}$:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> core::<span style=color:#66d9ef>f32</span>::consts::{PI, FRAC_PI_2};
</span></span></code></pre></div><p>Because we need to access the player&rsquo;s angle and position, let&rsquo;s create a method inside of <code>State</code> called <code>horizontal_intersection</code>.
This is the most complex function we&rsquo;ve written so far, but it mirrors the algorithm I&rsquo;ve already described so I&rsquo;m going to keep my comments <em>inside</em> the code for this one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Returns the nearest wall the ray intersects with on a horizontal grid line.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>horizontal_intersection</span>(<span style=color:#f92672>&amp;</span>self, angle: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This tells you if the angle is &#34;facing up&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// regardless of how big the angle is.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> up <span style=color:#f92672>=</span> fabsf(floorf(angle <span style=color:#f92672>/</span> PI) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2.0</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// first_y and first_x are the first grid intersections
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// that the ray intersects with.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> first_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> up {
</span></span><span style=display:flex><span>            ceilf(self.player_y) <span style=color:#f92672>-</span> self.player_y
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            floorf(self.player_y) <span style=color:#f92672>-</span> self.player_y
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> first_x <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>first_y <span style=color:#f92672>/</span> tanf(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dy and dx are the &#34;ray extension&#34; values mentioned earlier.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> dy <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> up { <span style=color:#ae81ff>1.0</span> } <span style=color:#66d9ef>else</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dx <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>dy <span style=color:#f92672>/</span> tanf(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// next_x and next_y are mutable values which will keep track
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// of how far away the ray is from the player.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_x <span style=color:#f92672>=</span> first_x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_y <span style=color:#f92672>=</span> first_y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This is the loop where the ray is extended until it hits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the wall. It&#39;s not an infinite loop as implied in the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// explanation, instead it only goes from 0 to 256.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This was chosen because if something goes wrong and the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// ray never hits a wall (which should never happen) the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// loop will eventually break and the game will keep on running.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>256</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// current_x and current_y are where the ray is currently
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// on the map. While next_x and next_y are relative
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// coordinates, current_x and current_y are absolute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// points.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> current_x <span style=color:#f92672>=</span> next_x <span style=color:#f92672>+</span> self.player_x;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> current_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> up {
</span></span><span style=display:flex><span>                next_y <span style=color:#f92672>+</span> self.player_y
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                next_y <span style=color:#f92672>+</span> self.player_y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Tell the loop to quit if we&#39;ve just hit a wall.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> point_in_wall(current_x, current_y) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// if we didn&#39;t hit a wall on this extension add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// dx and dy to our current position and keep going.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            next_x <span style=color:#f92672>+=</span> dx;
</span></span><span style=display:flex><span>            next_y <span style=color:#f92672>+=</span> dy;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// return the distance from next_x and next_y to the player.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        distance(next_x, next_y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=vertical-intersections-1>Vertical Intersections
<a href=#vertical-intersections-1 class=h-anchor aria-hidden=true>#</a></h3><p>Let&rsquo;s also implement vertical intersections before drawing the walls.</p><p>You&rsquo;ll notice that this function is almost identical to the last one.
Let&rsquo;s add a method inside of <code>State</code> called <code>vertical_intersection</code> to match <code>horizontal_intersection</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Returns the nearest wall the ray intersects with on a vertical grid line.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>vertical_intersection</span>(<span style=color:#f92672>&amp;</span>self, angle: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This tells you if the angle is &#34;facing up&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// regardless of how big the angle is.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> right <span style=color:#f92672>=</span> fabsf(floorf((angle <span style=color:#f92672>-</span> FRAC_PI_2) <span style=color:#f92672>/</span> PI) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2.0</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// first_y and first_x are the first grid intersections
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// that the ray intersects with. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> first_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> right {
</span></span><span style=display:flex><span>            ceilf(self.player_x) <span style=color:#f92672>-</span> self.player_x
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            floorf(self.player_x) <span style=color:#f92672>-</span> self.player_x
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> first_y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>tanf(angle) <span style=color:#f92672>*</span> first_x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dy and dx are the &#34;ray extension&#34; values mentioned earlier.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> dx <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> right { <span style=color:#ae81ff>1.0</span> } <span style=color:#66d9ef>else</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dy <span style=color:#f92672>=</span> dx <span style=color:#f92672>*</span> <span style=color:#f92672>-</span>tanf(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// next_x and next_y are mutable values which will keep track
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// of how far away the ray is from the player.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_x <span style=color:#f92672>=</span> first_x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_y <span style=color:#f92672>=</span> first_y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This is the loop where the ray is extended until it hits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the wall. It&#39;s not an infinite loop as implied in the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// explanation, instead it only goes from 0 to 256.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This was chosen because if something goes wrong and the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// ray never hits a wall (which should never happen) the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// loop will eventually quit and the game will keep on running.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>256</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// current_x and current_y are where the ray is currently
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// on the map. While next_x and next_y are relative
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// coordinates, current_x and current_y are absolute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// points.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> current_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> right {
</span></span><span style=display:flex><span>                next_x <span style=color:#f92672>+</span> self.player_x
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                next_x <span style=color:#f92672>+</span> self.player_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> current_y <span style=color:#f92672>=</span> next_y <span style=color:#f92672>+</span> self.player_y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Tell the loop to quit if we&#39;ve just hit a wall.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> point_in_wall(current_x, current_y) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// if we didn&#39;t hit a wall on this extension add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// dx and dy to our current position and keep going.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            next_x <span style=color:#f92672>+=</span> dx;
</span></span><span style=display:flex><span>            next_y <span style=color:#f92672>+=</span> dy;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// return the distance from next_x and next_y to the player.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        distance(next_x, next_y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=getting-the-view>Getting The View
<a href=#getting-the-view class=h-anchor aria-hidden=true>#</a></h3><p>So far we haven&rsquo;t written anything we can interact with.
Well, we can <em>act</em> on it (move the character), but we can&rsquo;t see what we&rsquo;re doing.
Let&rsquo;s try drawing the walls.</p><p>If you remember from the <a href=#summary>summary</a>, we have to draw vertical lines for every column on the window.</p><p>We can split this up into two separate jobs: getting the heights of the lines and actually drawing them on the screen.
Why not do this all at once?
Well, <code>vline</code> is <code>unsafe</code> so we should keep it in <code>fn update</code>.</p><p>Let&rsquo;s do this by defining <code>State::get_view</code> which returns a list of all the wall heights.
Then, on each frame, we can call <code>State::get_view</code> from <code>fn update</code> and draw all of those vertical lines we just calculated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>update</span>() {
</span></span><span style=display:flex><span>    STATE.update(
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_UP <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_DOWN <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_LEFT <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_RIGHT <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// go through each column on screen and draw walls in the center.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (x, wall_height) <span style=color:#66d9ef>in</span> STATE.get_view().iter().enumerate() {
</span></span><span style=display:flex><span>        vline(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>, <span style=color:#ae81ff>80</span> <span style=color:#f92672>-</span> (wall_height <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>), <span style=color:#f92672>*</span>wall_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>State::get_view</code> will work by going through each vertical line on the screen (all 160), calculating the angle offset from the player&rsquo;s point of view, then finding the distance to the closest horizontal and vertical intersections with walls in the ray&rsquo;s path.
Then it compares the two distances and turns the smaller of the two into the height of a wall.</p><p>I know that sounds complicated so let&rsquo;s go ahead and write out what that looks like.</p><p>First, let&rsquo;s create some constants which define our player&rsquo;s perspective:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> FOV: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> PI <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.7</span>; <span style=color:#75715e>// The player&#39;s field of view.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> HALF_FOV: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> FOV <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>; <span style=color:#75715e>// Half the player&#39;s field of view.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> ANGLE_STEP: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> FOV <span style=color:#f92672>/</span> <span style=color:#ae81ff>160.0</span>; <span style=color:#75715e>// The angle between each ray.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> WALL_HEIGHT: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100.0</span>; <span style=color:#75715e>// A magic number.
</span></span></span></code></pre></div><p>Now, let&rsquo;s add <code>get_view</code> to our existing <code>State</code> impl block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Returns 160 wall heights from the player&#39;s perspective.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_view</span>(<span style=color:#f92672>&amp;</span>self) -&gt; [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>160</span>] {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The player&#39;s FOV is split in half by their viewing angle.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// In order to get the ray&#39;s first angle we must
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// add half the FOV to the player&#39;s angle to get
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the edge of the player&#39;s FOV.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> starting_angle <span style=color:#f92672>=</span> self.player_angle <span style=color:#f92672>+</span> HALF_FOV;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> walls <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>160</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (idx, wall) <span style=color:#66d9ef>in</span> walls.iter_mut().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// `idx` is what number ray we are, `wall` is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// a mutable reference to a value in `walls`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> angle <span style=color:#f92672>=</span> starting_angle <span style=color:#f92672>-</span> idx <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span> <span style=color:#f92672>*</span> ANGLE_STEP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get both the closest horizontal and vertical wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// intersections for this angle.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> h_dist <span style=color:#f92672>=</span> self.horizontal_intersection(angle);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> v_dist <span style=color:#f92672>=</span> self.vertical_intersection(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get the minimum of the two distances and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// &#34;convert&#34; it into a wall height.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>*</span>wall <span style=color:#f92672>=</span> (WALL_HEIGHT <span style=color:#f92672>/</span> <span style=color:#66d9ef>f32</span>::min(h_dist, v_dist)) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        walls
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looks good, let&rsquo;s try running it!
You can use the arrow keys on your keyboard to move the player around.</p><figure class=center><video style=border-radius:8px;transform:translateX(-25%);-webkit-transform:translateX(-25%);margin-left:auto;margin-right:auto width=200% height=200% autoplay loop muted>
<source src=first-attempt.webm type=video/webm></video></figure><p>Wow, we were able to create the illusion of depth!
This is pretty impressive for our first try.
Most tutorials stop here, but there are some problems we need to work out.</p><h2 id=fixing-the-perspective>Fixing The Perspective
<a href=#fixing-the-perspective class=h-anchor aria-hidden=true>#</a></h2><p>When walking around you might notice that everything looks&mldr; wrong.
Walls bend away from you as if you were looking through a fisheye lens.</p><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/fisheye_hu9626be93642bcf1de6ff4147af7184fd_1049_325x0_resize_box_3.png width=325 height=325></figure><p>This is because our algorithm&rsquo;s assumption that human vision converges on a single infinitely small point (the player) is wrong.
In reality, our visual cortex is constantly blending the perspective of both of our eyes to create depth.</p><p>In this case a much more accurate metaphor is a plane perpendicular to our perspective sending out the rays:</p><figure class=left><img src=./figure-perspective.svg></figure><p>Of course this is pretty vague, but if you think of it as &ldquo;fisheye correction&rdquo; maybe that&rsquo;ll help.
To apply this &ldquo;fisheye correction&rdquo; we have to multiply the distance by the cosine of difference between the ray&rsquo;s angle and the player&rsquo;s angle:</p><p>$$ H= \frac{C}{D \times \cos(\Delta \theta)} $$</p><p>Where $H$ is the wall height in pixels, $D$ is the distance to the wall, and $ \Delta\theta$ is the difference between the ray&rsquo;s angle and the player&rsquo;s angle.</p><p>All we have to do to apply this is to modify a single line in the <code>State::get_view</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#f92672>*</span>wall <span style=color:#f92672>=</span> ( WALL_HEIGHT <span style=color:#f92672>/</span> (<span style=color:#66d9ef>f32</span>::min(h_dist, v_dist) <span style=color:#f92672>*</span> cosf(angle <span style=color:#f92672>-</span> self.player_angle)) ) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>;    
</span></span></code></pre></div><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/corrected_hu852e96f4adfe6a12090912b0c99e9388_645_325x0_resize_box_3.png width=325 height=325></figure><p>Great! Now the walls are straight.</p><h2 id=adding-some-depth>Adding Some Depth
<a href=#adding-some-depth class=h-anchor aria-hidden=true>#</a></h2><p>One thing about the current version of the game is that it is difficult to distinguish between different walls.
Especially at a distance, walls seem to fade into each other and it&rsquo;s hard to tell them apart.</p><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/nodepth_hu33c8e768c3a605f6dbc2d1420ad25207_1249_325x0_resize_box_3.png width=325 height=325></figure><p>In real life, we can distinguish walls apart by their shadows.
We can try to emulate this in the game by coloring walls differently based on their orientation.
Luckily for us, we already know which walls are &ldquo;east/west facing&rdquo; and which are &ldquo;north/south facing&rdquo; because of what axis our rays intersected with them!
Knowing this, it&rsquo;s fairly easy to assign different colors to walls.</p><p>WASM-4 has a very unique way of setting which color its functions use to draw.
Every time a draw function is called in WASM-4 it decides what color to use based on an index kept a bit of memory called <code>DRAW_COLORS</code>.
WASM-4 makes changing <code>DRAW_COLORS</code> easy, we can set it by using simple hex notation.</p><p>Let&rsquo;s add <code>DRAW_COLORS</code> next to <code>GAMEPAD1</code> at the top of our file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> DRAW_COLORS: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u16</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x14</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> GAMEPAD1: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x16</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>;    
</span></span></code></pre></div><p>Now, in <code>State::get_view</code>, we can rewrite it to pass along if the wall should be drawn &ldquo;with a shadow&rdquo; or not:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Returns 160 wall heights and their &#34;color&#34; from the player&#39;s perspective.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_view</span>(<span style=color:#f92672>&amp;</span>self) -&gt; [(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>bool</span>); <span style=color:#ae81ff>160</span>] {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The player&#39;s FOV is split in half by their viewing angle.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// In order to get the ray&#39;s starting angle we must
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// add half the FOV to the player&#39;s angle to get
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the edge of the player&#39;s FOV.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> starting_angle <span style=color:#f92672>=</span> self.player_angle <span style=color:#f92672>+</span> HALF_FOV;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> walls <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>false</span>); <span style=color:#ae81ff>160</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (idx, wall) <span style=color:#66d9ef>in</span> walls.iter_mut().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// `idx` is what number ray we are, `wall` is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// a mutable reference to a value in `walls`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> angle <span style=color:#f92672>=</span> starting_angle <span style=color:#f92672>-</span> idx <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span> <span style=color:#f92672>*</span> ANGLE_STEP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get both the closest horizontal and vertical wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// intersections for this angle.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> h_dist <span style=color:#f92672>=</span> self.horizontal_intersection(angle);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> v_dist <span style=color:#f92672>=</span> self.vertical_intersection(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> (min_dist, shadow) <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> h_dist <span style=color:#f92672>&lt;</span> v_dist {
</span></span><span style=display:flex><span>                (h_dist, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                (v_dist, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get the minimum of the two distances and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// &#34;convert&#34; it into a wall height.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>*</span>wall <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>                (WALL_HEIGHT <span style=color:#f92672>/</span> (min_dist <span style=color:#f92672>*</span> cosf(angle <span style=color:#f92672>-</span> self.player_angle))) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>                shadow,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        walls
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now let&rsquo;s make these changes in <code>fn update</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>update</span>() {
</span></span><span style=display:flex><span>    STATE.update(
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_UP <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_DOWN <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_LEFT <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>GAMEPAD1 <span style=color:#f92672>&amp;</span> BUTTON_RIGHT <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Go through each column on screen and draw walls in the center.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (x, wall) <span style=color:#66d9ef>in</span> STATE.get_view().iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (height, shadow) <span style=color:#f92672>=</span> wall;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>shadow {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// draw with color 2 for walls with &#34;shadow&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>*</span>DRAW_COLORS <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x2</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// draw with color 3 for walls without &#34;shadow&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>*</span>DRAW_COLORS <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x3</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        vline(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>, <span style=color:#ae81ff>80</span> <span style=color:#f92672>-</span> (height <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>), <span style=color:#f92672>*</span>height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Lets try running it:</p><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/depth_huab4f183ccc454923b80459d4a3cea9b4_1198_325x0_resize_box_3.png width=325 height=325></figure><p>Wow, that looks much better.
Even though shadows in real life don&rsquo;t act like this it adds some good detail and helps create the illusion of depth.</p><h2 id=making-it-smaller>Making It Smaller!
<a href=#making-it-smaller class=h-anchor aria-hidden=true>#</a></h2><p>If you were to check the size of the program right now, say by calling <code>du -bh</code>, you might get something like this:</p><pre tabindex=0><code>12K  target/wasm32-unknown-unknown/release/raycaster.wasm
</code></pre><p>This is nowhere near the 2K executable I promised in the title, so how are we going to get there?
One way you can reduce the size of <code>.wasm</code> files is by using <code>wasm-opt</code>.
You can usually get <code>wasm-opt</code> by installing the <a href=https://pkgs.org/download/binaryen rel=noopener target=_blank><code>binaryen</code></a> package.
<code>wasm-opt</code> was specifically designed to optimize <code>.wasm</code> files for size by removing dead code and duplicate instructions that the compiler left behind.</p><p>Let&rsquo;s put a <code>wasm-opt</code> step in our <code>Makefile</code> and while we&rsquo;re at it let&rsquo;s make it tell us what size the <code>.wasm</code> file is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>all</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.SILENT</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	cargo build --release
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	wasm-opt -Oz target/wasm32-unknown-unknown/release/raycaster.wasm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o target/wasm32-unknown-unknown/release/raycaster.wasm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>size</span><span style=color:#f92672>:</span> all
</span></span><span style=display:flex><span>	du -bh target/wasm32-unknown-unknown/release/raycaster.wasm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>run</span><span style=color:#f92672>:</span> all
</span></span><span style=display:flex><span>	w4 run-native target/wasm32-unknown-unknown/release/raycaster.wasm
</span></span></code></pre></div><pre tabindex=0><code> $ make size
7.2K  target/wasm32-unknown-unknown/release/raycaster.wasm
</code></pre><p>Hmmm, not quite enough.</p><h2 id=somehow-even-smaller>Somehow Even Smaller?!
<a href=#somehow-even-smaller class=h-anchor aria-hidden=true>#</a></h2><p>If you were to look into the executable you&rsquo;d probably see that most of the space is being taken up by functions we imported from <code>libm</code>.
The final step requires we remove <code>libm</code> completely and replace it with our own implementation.</p><p>Let&rsquo;s start by deleting the old <code>libm</code> import statement and removing it from <code>Cargo.toml</code>.
After that we can add an approximation of the <code>sinf</code> function using <a href=https://en.wikipedia.org/wiki/Bhaskara_I%27s_sine_approximation_formula rel=noopener target=_blank>Bhasksara I&rsquo;s sin approximation</a> and redefine <code>cosf</code> and <code>tanf</code> in terms of it.</p><p>$$
\sin(x) \approx \frac{16x(\pi-x)}{5\pi^2-4x(\pi-x)} \text{ when } (0 \le x \le \pi)
$$</p><p>This approximation is <em>extremely</em> good, especially for the time it was discovered.
And because we&rsquo;re operating with wall heights only between 0 and 160, any differences between <code>libm::sinf</code> and our <code>sinf</code> will be indistinguishable.</p><p>First, make sure to also import $\tau$ from the core library and define a constant for $5\pi^2$ which Bhaskara I&rsquo;s approximation uses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> core::<span style=color:#66d9ef>f32</span>::consts::{FRAC_PI_2, PI, TAU};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> FIVE_PI_SQUARED: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5.0</span> <span style=color:#f92672>*</span> (PI <span style=color:#f92672>*</span> PI);
</span></span></code></pre></div><p>Then, let&rsquo;s add our new <code>sinf</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sinf</span>(<span style=color:#66d9ef>mut</span> x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> x <span style=color:#f92672>/</span> TAU;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> y <span style=color:#f92672>-</span> floorf(y);
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> z <span style=color:#f92672>*</span> TAU;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sinf_imp <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>x: <span style=color:#66d9ef>f32</span><span style=color:#f92672>|</span> -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// these magic numbers were discovered 1400 years ago!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (<span style=color:#ae81ff>16.0</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> (PI <span style=color:#f92672>-</span> x)) <span style=color:#f92672>/</span> (FIVE_PI_SQUARED <span style=color:#f92672>-</span> (<span style=color:#ae81ff>4.0</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> (PI <span style=color:#f92672>-</span> x)))
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;</span> PI {
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span>sinf_imp(x <span style=color:#f92672>-</span> PI)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        sinf_imp(x)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can create <code>cosf</code> and <code>tanf</code> functions from their definitions relating to <code>sinf</code>:</p><p>$\cos(x) = \sin(x + \frac{\pi}{2})$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cosf</span>(x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    sinf(x <span style=color:#f92672>+</span> FRAC_PI_2)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>$\tan(x) = \frac{\sin(x)}{\cos(x)}$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>tanf</span>(x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    sinf(x) <span style=color:#f92672>/</span> cosf(x)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Alright, now that we&rsquo;ve replaced the <code>libm</code> trig functions, what about <code>sqrtf</code>, <code>ceilf</code>, <code>floorf</code>, and <code>fabsf</code>?
This is where <em>nightly</em> Rust comes into play, so make sure you&rsquo;ve &ldquo;<code>rustup default nightly</code>ed yourself&rdquo; or build the project with nightly features enabled from now on.</p><p>Nightly Rust enables us to use an experimental module in the core library named <code>core::intrinsics</code>.
<code>core::intrinsics</code> provides us some functions that the compiler knows how to optimize so we don&rsquo;t have to write them ourself.
In order to turn on the experimental intrinsics feature, add <code>#![feature(core_intrinsics)]</code> to the top of your file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#![no_std]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![feature(core_intrinsics)]</span>
</span></span></code></pre></div><p>Now we can create some &ldquo;safe&rdquo; wrappers over the unsafe functions that <code>core::intrinsics</code> provides for us:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sqrtf</span>(x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { core::intrinsics::sqrtf32(x) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>floorf</span>(x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { core::intrinsics::floorf32(x) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>ceilf</span>(x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { core::intrinsics::ceilf32(x) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fabsf</span>(x: <span style=color:#66d9ef>f32</span>) -&gt; <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { core::intrinsics::fabsf32(x) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Lets compile to and see if it works&mldr; and</p><pre tabindex=0><code>$ make size
1.7K	target/wasm32-unknown-unknown/release/raycaster.wasm
</code></pre><h2 id=conclusion>Conclusion
<a href=#conclusion class=h-anchor aria-hidden=true>#</a></h2><p>1.7K is not the smallest you can make this program.
You can get this to fit in even smaller sizes and I encourage you to try!
There are some sections in this code that I&rsquo;ve even intentionally made more readable at the cost of taking up slightly more instructions than they need to just so <em>you</em> can optimize it.</p><p>I wrote this post because when I was first writing my raycasted game I couldn&rsquo;t find any resources that explained how the algorithm worked in sane code and plain language.</p><p>I hope this was interesting and useful for you!
Ray casting in FPS games was always a mystery to me before I looked into them, I hope you&rsquo;ll agree that the algorithm behind it is surprisingly elegant.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>In this post I call specific the ray casting algorithm used in games like Wolfenstein 3D &ldquo;ray casting&rdquo; for the sake of brevity. This is slightly inaccurate as ray casting has a more general meaning in the field of graphics. See the <a href=https://en.wikipedia.org/wiki/Ray_casting>Wikipedia Article</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>To say &ldquo;extending the ray&rdquo; is a bit of a misnomer. &ldquo;vector&rdquo; is more accurate in this situation but &ldquo;ray&rdquo; sounds better and is in the name &ldquo;ray casting&rdquo; so I use it in its place.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Thanks to <a href=https://github.com/Cyborus04 rel=noopener target=_blank>Cyborus04</a> for helping me with this <code>sinf</code> function.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user">&copy; 2023 Grant Handy</div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>