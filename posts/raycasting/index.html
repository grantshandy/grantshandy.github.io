<!doctype html><html lang=en><head><title>Work In Progress - Write a 2KB FPS with Rust ::
grantsh</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction # In this post we will uncover an elegant algorithm and create tiny first-person game with Rust. I wrote this because I couldn&amp;rsquo;t find any solid in-depth resources about ray casting while designing my own game. Here&amp;rsquo;s a quick preview of what we&amp;rsquo;ll be making:
My first experience with games like this (though I didn&amp;rsquo;t know at the time), was in middle school with games like zDoom for the TI-84 plus."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://grantshandy.github.io/posts/raycasting/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://grantshandy.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://grantshandy.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://grantshandy.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://grantshandy.github.io/posts/raycasting/cover.png"><meta name=twitter:title content="Work In Progress - Write a 2KB FPS with Rust"><meta name=twitter:description content="Learn about raycasting and discover some elegant math by creating a tiny 4KB game with Rust."><meta property="og:title" content="Work In Progress - Write a 2KB FPS with Rust"><meta property="og:description" content="Learn about raycasting and discover some elegant math by creating a tiny 4KB game with Rust."><meta property="og:type" content="article"><meta property="og:url" content="https://grantshandy.github.io/posts/raycasting/"><meta property="og:image" content="https://grantshandy.github.io/posts/raycasting/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-18T00:00:00+00:00"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,align:"center",theme:"neutral"})</script><script src=https://www.geogebra.org/apps/deployggb.js></script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=https://grantshandy.github.io/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>grantsh</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/showcase>Showcase</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/showcase>Showcase</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>Work In Progress - Write a 2KB FPS with Rust</h1><div class=post-meta><time class=post-date>2023-02-18</time>
<span class=post-read-time>— 7 min read</span></div><figure class=post-cover><img src=https://grantshandy.github.io/posts/raycasting/cover.png alt="Work In Progress - Write a 2KB FPS with Rust"></figure><div class=post-content><h2>Table of Contents</h2><aside class=table-of-contents><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#wolfenstein-3d>Wolfenstein 3D</a></li></ul></li><li><a href=#the-algorithm>The Algorithm</a><ul><li><a href=#the-basics>The Basics</a></li><li><a href=#digging-deeper>Digging Deeper</a></li><li><a href=#horizontal-intersections>Horizontal Intersections</a></li><li><a href=#vertical-intersections>Vertical Intersections</a></li><li><a href=#overview>Overview</a></li></ul></li><li><a href=#implementation>Implementation</a><ul><li><a href=#wasm-4>WASM-4?</a></li><li><a href=#project-setup>Project Setup</a></li><li><a href=#horizontal-intersections-1>Horizontal Intersections</a></li><li><a href=#vertical-intersections-1>Vertical Intersections</a></li><li><a href=#why-do-my-walls-look-so-funny>Why Do My Walls Look So Funny?</a></li><li><a href=#even-smaller>Even Smaller!</a></li><li><a href=#even-smaller-1>Even Smaller?!</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><h2 id=introduction>Introduction
<a href=#introduction class=h-anchor aria-hidden=true>#</a></h2><p>In this post we will uncover an elegant algorithm and create tiny first-person game with Rust.
I wrote this because I couldn&rsquo;t find any solid in-depth resources about ray casting while designing my own game.
Here&rsquo;s a quick preview of what we&rsquo;ll be making:</p><figure class=center><img style=max-width:100%;width:auto;height:auto;border-radius:8px src=/posts/raycasting/preview_hu0cc740388709afc917ff27a8284fb48a_232110_480x480_resize_box_1.gif width=160 height=160></figure><p>My first experience with games like this (though I didn&rsquo;t know at the time), was in middle school with games like <a href=https://www.ticalc.org/archives/files/fileinfo/360/36062.html>zDoom</a> for the TI-84 plus.
ZDoom (while probably not as fun as <a href=https://www.ticalc.org/archives/files/fileinfo/336/33606.html>snake</a>), provided the feeling of playing a &ldquo;cool&rdquo; game because of it&rsquo;s unique &ldquo;3D&rdquo; graphics and brand association.
zDoom, while only an imitation of the original Doom, is much closer to it&rsquo;s technical predecesor, Wolfenstein 3D.</p><h3 id=wolfenstein-3d>Wolfenstein 3D
<a href=#wolfenstein-3d class=h-anchor aria-hidden=true>#</a></h3><p>Famously, <a href=https://en.wikipedia.org/wiki/Wolfenstein_3D>Wolfenstein 3D</a>, released in 1992, was one of the first 3D first-person games to run on consumer PCs.
Back then, computers didn&rsquo;t have 3D acceleration, let alone dedicated graphics cards, so how was this done?</p><figure class=center><img src=https://upload.wikimedia.org/wikipedia/en/6/69/Wolf3d_pc.png><figcaption class=center>A screenshot from wolfenstein 3D</figcaption></figure><p>Well, I should have said <a href=https://en.wikipedia.org/wiki/2.5D><em>pseudo</em>-3D</a> because no part of the game actually ran in three-dimensions.
The core of the game was an algorithm called ray casting<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, a process of projecting a 2D map into a 3D perspective.</p><p>All the game entities were located only at simple x and y positions on the map and could not move vertically.
Upon release, I&rsquo;m sure that this didn&rsquo;t show, but with our <a href=https://www.unrealengine.com/en-US/unreal-engine-5>current standards</a> it definitely does.
The player could not look up or down, let alone crouch or jump.</p><figure class=center><img src=wolfenstein-map.png><figcaption class=center>A top-down view of the first level of Wolfenstein 3D</figcaption></figure><p>To add to that, all levels were composed of single floors of buildings with no windows.
Also, all walls were perfectly straight with corners placed at even intervals (something that will definitely not come up later).
These design features were all put here because of some of the essential restrictions of it&rsquo;s simple ray casting algorithm.</p><h2 id=the-algorithm>The Algorithm
<a href=#the-algorithm class=h-anchor aria-hidden=true>#</a></h2><h3 id=the-basics>The Basics
<a href=#the-basics class=h-anchor aria-hidden=true>#</a></h3><p>At the most fundamental level, ray casting depends on the simple fact that objects that are further away from us appear smaller, while objects that are closer appear larger.
Ray casting uses this fact to draw draw walls at shorter heights the further away they from the player and taller heights the closer they are.</p><p>Just this simple idea alone creates a convincing illusion of depth and allows us to move our player around just as if it were being rendered in actual 3D.</p><p>Ray casting <em>works</em> by tracing a path from the player to the closest wall for each vertical column in the player&rsquo;s view.
It then records the distances of each paths before converting it into the height of a wall and drawing it on screen.</p><figure class=center><img src=figure-overview.svg></figure><p>Replace &ldquo;path&rdquo; with &ldquo;ray&rdquo; and &ldquo;trace&rdquo; with &ldquo;cast&rdquo; and now you know why it&rsquo;s called ray casting.</p><figure class=center><img src=https://upload.wikimedia.org/wikipedia/commons/e/e7/Simple_raycasting_with_fisheye_correction.gif><figcaption class=center>A visualization of the algorithm.</figcaption></figure><h3 id=digging-deeper>Digging Deeper
<a href=#digging-deeper class=h-anchor aria-hidden=true>#</a></h3><p>On paper it seems simple to draw a line and stop when it hits a wall, in practice it can be <a href=https://en.wikipedia.org/wiki/Collision_detection>pretty difficult</a>.
If you had to come up with a ray casting implementation yourself, how would you approach it?</p><figure class=center><img src=figure-question.svg><figcaption class=center>The Intersection Problem</figcaption></figure><p>The first idea most people would probably have is to repeatedly extend the ray<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> a small amount and stop when it hits a wall.
This is problematic because when extending the ray we might skip over the wall and miss it entirely.</p><figure class=center><img src=figure-naive.svg><figcaption class=center>The Naive Solution</figcaption></figure><p>Another idea you might have is to extend the ray to the edge of the map then check if any of the sides of the wall intersect with the ray through a simple <a href=https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection>line-line intersection check</a>.
Then you can calculate the distance to the nearest wall by using the smallest of the distances you found.
This is also problematic because the algorithm&rsquo;s <a href=https://en.wikipedia.org/wiki/Time_complexity>complexity</a> increases with each wall that we add to the map.</p><figure class=center><img src=figure-line-intersections.svg><figcaption class=center>Line-Intersection Checking</figcaption></figure><p>The best answer, as you might have guessed from the earlier foreshadowing, is to align the map to a grid.
If we align each wall to a grid section, we know that the ray can only intersect with the wall along grid lines.
With this information, we can just repeatedly extend the ray out to the next grid line (integer) and check to see if it&rsquo;s about to intersect with a wall.</p><figure class=center><img src=figure-solution.svg><figcaption class=center>Grid-Line Intersection Checking</figcaption></figure><p>The way we&rsquo;ll implement this takes strategies from both of the approaches previously mentioned.
First, we&rsquo;ll extend the ray along horizontal grid intersections, then we&rsquo;ll extend along vertical grid intersections.
After this we can simply choose the smaller of the two to find how far the wall is away from the player!</p><h3 id=horizontal-intersections>Horizontal Intersections
<a href=#horizontal-intersections class=h-anchor aria-hidden=true>#</a></h3><script>window.addEventListener("load",function(){new GGBApplet({appName:"geometry",id:"horizontal",width:800,height:600,showToolBar:!1,showZoomButtons:!1,showAlgebraInput:!1,showLogging:!1,enableRightClick:!1,enableShiftDragZoom:!1,preventFocus:!0,showMenuBar:!1,appletOnLoad:e=>{e.setCoordSystem(-2.78,13.18,-4.48,7.48)},filename:"https://grantshandy.github.io/ggb/horizontal.ggb"}).inject("horizontal")})</script><figure class=center><div id=horizontal style=border-radius:8px;overflow:hidden></div><figcaption class=center>Drag the player around to see how the ray intersects with the grid lines.</figcaption></figure><p>The nice thing about an evenly spaced grid is that the distance between grid intersections is constant.
In the case of horizontal grid intersections, the height between intersections is always 1, while the width can be derived from the angle of the ray.</p><p>You can see this by looking at the diagram, the width between Z and Y is the same as the width between X and Y, and the vertical distance between all points is one.
Using some simple trigonometry we can find the width between horizontal grid intersections.
I&rsquo;m going to save you the work and just give you the definition: <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>$$ \Delta H = \begin{cases} 1 &\text{if } \pi > \theta \ge 0 \text{ (facing up)} \\ -1 &\text{if } \tau > \theta \ge \pi \text{ (facing down)} \end{cases} $$
$$ \Delta W = \frac{\Delta H}{\tan(\theta)} $$</p><h3 id=vertical-intersections>Vertical Intersections
<a href=#vertical-intersections class=h-anchor aria-hidden=true>#</a></h3><script>window.addEventListener("load",function(){new GGBApplet({appName:"geometry",id:"vertical",width:800,height:600,showToolBar:!1,showZoomButtons:!1,showAlgebraInput:!1,showLogging:!1,enableRightClick:!1,enableShiftDragZoom:!1,preventFocus:!0,showMenuBar:!1,appletOnLoad:e=>{e.setCoordSystem(-3.097,8.238,2.274,10.769)},filename:"https://grantshandy.github.io/ggb/vertical.ggb"}).inject("vertical")})</script><figure class=center><div id=vertical style=border-radius:8px;overflow:hidden></div><figcaption class=center>Drag the player around to see how the ray intersects with the grid lines.</figcaption></figure><p>Vertical grid intersections are the same as horizontal grid intersections, just rotated 90°.
In vertical grid intersections the width between our &ldquo;ray extensions&rdquo; is the constant, while the height is created from the angle of the ray.
Like last time, I&rsquo;m going to skip ahead and define our variables for you. <sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>$$ \Delta W = \begin{cases} 1 &\text{if } \pi/2 > \theta > -\pi/2 \text{ (facing right)} \\ -1 &\text{if } 3\pi/4 > \theta > \pi/2 \text{ (facing left)} \end{cases} $$
$$ \Delta H = \Delta W * \tan(\theta) $$</p><h3 id=overview>Overview
<a href=#overview class=h-anchor aria-hidden=true>#</a></h3><p>With all the information we&rsquo;ve learned, we can write up the algorithm.</p><p>For each vertical line on screen:</p><ol><li>Find the relative angle from the player&rsquo;s angle and field of view.</li><li>Cast two rays from the player at our angle. One checks for horizontal intersections with walls and the other checks for vertical intersections.</li><li>Choose the smaller of the two intersections and draw a vertical line on the screen proportional to the distance to the wall.</li></ol><h2 id=implementation>Implementation
<a href=#implementation class=h-anchor aria-hidden=true>#</a></h2><p>Now that we understand how the underlying algorithm works we can write a program that implements it using Rust and WASM-4.</p><h3 id=wasm-4>WASM-4?
<a href=#wasm-4 class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://wasm4.org>WASM-4</a> is a tiny game engine which runs WebAssembly (<code>.wasm</code>) files.
Most compiled languages (C, C++, Rust, Zig, etc.) can compile to WebAssembly, so games for WASM-4 can be written in any of those languages.
WASM-4 is extremely minimal, it is named &ldquo;WASM-4&rdquo; because it executes <code>.wasm</code> files, and only lets you draw four colors on screen at once.</p><div class=mermaid>graph LR
source[lib.rs] --> compiler[rustc] --> wasm
subgraph wasm4[WASM-4]
wasm[game.wasm]
end
wasm4--> player[Player]</div><p>In our case, WASM-4 is very useful because it lets us create tiny, self-contained games and provides helpful functions like <code>vline</code>.
All you need to run WASM-4 games is to <a href=https://wasm4.org/docs/getting-started/setup>download and install the minimal runtime</a>.</p><h3 id=project-setup>Project Setup
<a href=#project-setup class=h-anchor aria-hidden=true>#</a></h3><p>Because WASM-4 runs WebAssembly files, we have to configure our cargo project accordingly (with a few minor tweaks).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo new raycaster --lib <span style=color:#f92672>&amp;&amp;</span> cd raycaster
</span></span></code></pre></div><p>Add to <code>Cargo.toml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>lib</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>crate-type</span> = [<span style=color:#e6db74>&#34;cdylib&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>profile</span>.<span style=color:#a6e22e>release</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>opt-level</span> = <span style=color:#e6db74>&#34;z&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lto</span> = <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>This will tell cargo that we want to produce a C-like dynamic library (<code>.wasm</code>), and optimize the binary for size.</p><p>In our cargo project configuration file <code>.cargo/config.toml</code> add:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>build</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>target</span> = <span style=color:#e6db74>&#34;wasm32-unknown-unknown&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>wasm32-unknown-unknown</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>rustflags</span> = [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=--import-memory&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=--initial-memory=65536&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=--max-memory=65536&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-C&#34;</span>, <span style=color:#e6db74>&#34;link-arg=-zstack-size=14752&#34;</span>,
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>This will tell cargo to use WebAssembly by default, and pass some flags to <code>rustc</code> telling our program to reserve some memory for the game.</p><h3 id=horizontal-intersections-1>Horizontal Intersections
<a href=#horizontal-intersections-1 class=h-anchor aria-hidden=true>#</a></h3><h3 id=vertical-intersections-1>Vertical Intersections
<a href=#vertical-intersections-1 class=h-anchor aria-hidden=true>#</a></h3><h3 id=why-do-my-walls-look-so-funny>Why Do My Walls Look So Funny?
<a href=#why-do-my-walls-look-so-funny class=h-anchor aria-hidden=true>#</a></h3><h3 id=even-smaller>Even Smaller!
<a href=#even-smaller class=h-anchor aria-hidden=true>#</a></h3><h3 id=even-smaller-1>Even Smaller?!
<a href=#even-smaller-1 class=h-anchor aria-hidden=true>#</a></h3><h2 id=conclusion>Conclusion
<a href=#conclusion class=h-anchor aria-hidden=true>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>In this post I call specific the ray casting algorithm used in games like Wolfenstein 3D &ldquo;ray casting&rdquo; for the sake of brevity. This is slightly innacurrate as ray casting has a more general meaning in the field of graphics. See the <a href=https://en.wikipedia.org/wiki/Ray_casting>Wikipedia Article</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>To say &ldquo;extending the ray&rdquo; is a bit of a misnomer. &ldquo;vector&rdquo; is more accurate in this situation but &ldquo;ray&rdquo; sounds better.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>This definition is slightly different than what is in the implementation because our player angle won&rsquo;t always be between 0 and 𝜏. The coordinate system will also be vertically flipped.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user">&copy; 2023 Grant Handy</div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>